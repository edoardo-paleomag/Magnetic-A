sigma_U <- (S_val[2]+S_val[3])/2
Wu <- matrix(S_vec[,1]*sqrt(S_val[1]-sigma_U))
WTW <- Wu %*% t(Wu)
Cu <- (WTW)+(sigma_U*I)
dCu <- det(Cu)
iCu <- MASS::ginv(Cu)
LogLu <- -(nrow(dat_U)/2)*((3*log(2*pi))+(log(dCu))+(sum(diag(iCu %*% S))))
BIC_Hu <- (-2*LogLu)+(8*log(nrow(dat_U)))
#calculate Free Vector
Dec_U<- (r2d(atan2(Wu[2,1],Wu[1,1])))%%360
Inc_U <- r2d(asin(Wu[3,1]/(sqrt((Wu[1,1]^2)+(Wu[2,1]^2)+(Wu[3,1]^2)))))
MADu <- r2d(atan(sqrt((2*sigma_U/S_val[1]))))
#flipping Dec_U module, if directions goes opposite to vector tip
tip <- c(dat[1,1]-dat[nrow(dat),1],dat[1,2]-dat[nrow(dat),2],dat[1,3]-dat[nrow(dat),3])
tipdec <- (r2d(atan2(tip[2],tip[1])))%%360
tipinc <- r2d(asin(tip[3]/(sqrt((tip[1]^2)+(tip[2]^2)+(tip[3]^2)))))
deltadec_tip_V1_U<- abs(tipdec-Dec_U)
dist_tip_V1_U <- r2d(acos((sin(d2r(tipinc))*sin(d2r(Inc_U)))+
(cos(d2r(tipinc))*cos(d2r(Inc_U))*cos(d2r(deltadec_tip_V1_U)))))
if(dist_tip_V1_U>90){
Dec_U <- (Dec_U+180)%%360
Inc_U <- -Inc_U
}
#same process for anchored data
sigma_A <- (Sa_val[2]+Sa_val[3])/2
Wa <- matrix(Sa_vec[,1]*sqrt(Sa_val[1]-sigma_A))
WaTWa <- Wa %*% t(Wa)
Ca <- (WaTWa)+(sigma_A*I)
dCa <- det(Ca)
iCa <- MASS::ginv(Ca)
LogLa <- -(nrow(dat_A)/2)*((3*log(2*pi))+(log(dCa))+(sum(diag(iCa %*% Sa))))
BIC_Ha <- (-2*LogLa)+(5*log(nrow(dat_A)))
#calculate Anchored Vector
Dec_A<- (r2d(atan2(Wa[2,1],Wa[1,1])))%%360
Inc_A <- r2d(asin(Wa[3,1]/(sqrt((Wa[1,1]^2)+(Wa[2,1]^2)+(Wa[3,1]^2)))))
MADa <- r2d(atan(sqrt((2*sigma_A/Sa_val[1]))))
#flipping Dec_U module, if directions goes opposite to vector tip
deltadec_tip_V1_A<- abs(tipdec-Dec_A)
dist_tip_V1_A <- r2d(acos((sin(d2r(tipinc))*sin(d2r(Inc_A)))+
(cos(d2r(tipinc))*cos(d2r(Inc_A))*cos(d2r(deltadec_tip_V1_A)))))
if(dist_tip_V1_A>90){
Dec_A <- (Dec_A+180)%%360
Inc_A <- -Inc_A
}
#Calculate BF and probability
BF <- exp((BIC_Ha-BIC_Hu)/2)
pHa <- round((1/(BF+1)),digits = 3)
C_init_Sig <- sigma_U
C_init_Lam <- Wu[1,1]^2+Wu[2,1]^2+Wu[3,1]^2+(sigma_U)
N <- nrow(dat)
# Initial parameters for LogLc (constrained) estimate
start_vals <- c(sigma = C_init_Sig,
lambda = C_init_Lam)
#function for calculating LogLc
LogLc <- function(SL) {
sigma_sq <- SL[1]
lambda <- SL[2]
diff_val <- sqrt(lambda - sigma_sq)
norm_factor <- sqrt(x_av^2 + y_av^2 + z_av^2)
# Calcola Wc
Wc <- matrix(c(
(x_av / norm_factor) * diff_val,
(y_av / norm_factor) * diff_val,
(z_av / norm_factor) * diff_val),
nrow = 1, ncol = 3)
Noise <- sigma_sq * diag(3)
Cc <- (t(Wc) %*% Wc) + Noise
iCc <- solve(Cc)
# Determinante
dCc <- det(Cc)
# Controllo matrice inversa
if (any(is.nan(iCc)) || any(is.infinite(iCc))) {return(1e6)}
# Calcolo log-verosimiglianza
result <- -(N / 2) * ((3 * log(2 * pi)) + log(dCc) + sum(diag(iCc %*% S)))
return(result)
}
# Funzione di ottimizzazione con vincoli
optim_wrapper <- function(SL) {
sigma_sq <- SL[1]
lambda <- SL[2]
# Vincolo: lambda deve essere maggiore di sqrt(sigma_sq)
if (lambda <= sqrt(sigma_sq)) {
return(1e6)  # Penalità per violazione del vincolo
}
return(-LogLc(SL))  # Negativa perché ottimizziamo per minimizzazione
}
# Valori iniziali (che conosci già)
start_vals <- c(sigma_sq = C_init_Sig,
lambda = C_init_Lam)
# Ottimizzazione con vincoli
opt_result <- optim(
par = start_vals,
fn = optim_wrapper,
method = "L-BFGS-B",
lower = c(1e-6, sqrt(start_vals[1]) + 1e-6),  # Evitiamo valori negativi e rispettiamo il vincolo
upper = c(Inf, Inf)  # Nessun limite superiore
)
#extrapolate necessary values
Sigma_C <- opt_result$par[1]
Lambda_C <- opt_result$par[2]
LogLc <- -opt_result$value
BIC_Hc <- (-2*LogLc)+(5*log(nrow(dat_A)))
HuVsHc <- exp((BIC_Hc-BIC_Hu)/2)
#calculate probability
pHc <- round(1/(1+HuVsHc),digits = 3)
#otimized constrained vector matrix
WcO <- matrix(c(
(x_av/sqrt(x_av^2 + y_av^2 + z_av^2)) * sqrt(Lambda_C-Sigma_C),
(y_av/sqrt(x_av^2 + y_av^2 + z_av^2)) * sqrt(Lambda_C-Sigma_C),
(z_av/sqrt(x_av^2 + y_av^2 + z_av^2)) * sqrt(Lambda_C-Sigma_C)),
nrow = 3, ncol = 1)
#calculate constrained Vector
Dec_C <- (r2d(atan2(WcO[2,1],WcO[1,1])))%%360
Inc_C <- r2d(asin(WcO[3,1]/(sqrt((WcO[1,1]^2)+(WcO[2,1]^2)+(WcO[3,1]^2)))))
MADc <- r2d(atan(sqrt((2*Sigma_C)/Lambda_C)))
#flipping Dec_U module, if directions goes opposite to vector tip
deltadec_tip_V1_C <- abs(tipdec-Dec_C)
dist_tip_V1_C <- r2d(acos((sin(d2r(tipinc))*sin(d2r(Inc_C)))+
(cos(d2r(tipinc))*cos(d2r(Inc_C))*cos(d2r(deltadec_tip_V1_C)))))
if(dist_tip_V1_C>90){
Dec_C <- (Dec_C+180)%%360
Inc_C <- -Inc_C
}
#producing text on anchoring
if(pHa<0.5){text1 <- "Free from origin interpolation"}
if(pHa>0.5){text1 <- "Anchored interpolation"}
if(pHa<0.01 || pHa >= 0.99) {text2 <- "very strongly"}
if((pHa>=0.01 && pHa<0.05) || (pHa>=0.95 && pHa<0.99)) {text2 <- "strongly"}
if((pHa>=0.05 && pHa<0.25) || (pHa>=0.75 && pHa<0.95)) {text2 <- "positively"}
if((pHa>=0.25 && pHa<0.5) || (pHa>0.5 && pHa<0.75)) {text2 <- "weakly"}
if(pHa==0.5){verdict <- "No preference about anchoring to the origin"}
else{verdict_a <- paste("p(Ha|D)=",pHa,text1,"is",text2,"supported",sep = " ")}
#producing text on constraining
if(pHc<0.5){text3 <- "Unconstrained interpolation"}
if(pHc>0.5){text3 <- "Constrained interpolation"}
if(pHc<0.01 || pHc >= 0.99) {text4 <- "very strongly"}
if((pHc>=0.01 && pHc<0.05) || (pHc>=0.95 && pHc<0.99)) {text4 <- "strongly"}
if((pHc>=0.05 && pHc<0.25) || (pHc>=0.75 && pHc<0.95)) {text4 <- "positively"}
if((pHc>=0.25 && pHc<0.5) || (pHc>0.5 && pHc<0.75)) {text4 <- "weakly"}
if(pHc==0.5){verdict_c <- "No preference about constraining"}
else{verdict_c <- paste("p(Hc|D)=",pHc,text3,"is",text4,"supported",sep = " ")}
#compile results table
All_directions <- data.frame(matrix(nrow = 3,ncol=6))
colnames(All_directions)=c("Dec","Inc","MAD","N","Log likelihood","BIC")
rownames(All_directions)=c("Free","Anchored","Constrained")
#compile result table
All_directions[1,1:6]=round(c(Dec_U,Inc_U,MADu,N,LogLu,BIC_Hu),digits = 2)
All_directions[2,1:6]=round(c(Dec_A,Inc_A,MADa,N,LogLa,BIC_Ha),digits = 2)
All_directions[3,1:6]=round(c(Dec_C,Inc_C,MADc,N,LogLc,BIC_Hc),digits = 2)
results <- list()
results$All_directions <- All_directions
results$verdict_a <- verdict_a
results$verdict_c <- verdict_c
results$pHa <- pHa
results$pHa <- pHc
return(results)
}
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_51.R')
PPCA_HR16_prova(butta)
#function that calculates probabilistic parameters of Heslop & Roberts 2016 (JGR:SE_10.1002/2016JB013387)
PPCA_HR16 <- function(VEPs){
#degree to radians and VV
d2r <- function(x) {x*(pi/180)}
r2d <- function(x) {x*(180/pi)}
dat <- VEPs
colnames(dat) <- c("x", "y","z")
dat$R <- sqrt((dat$x^2)+(dat$y^2)+(dat$z)^2)
#averaged Cartesian coordinates
x_av <- mean(dat$x)
y_av <- mean(dat$y)
z_av <- mean(dat$z)
#creat dataset for un-anchored data
dat_U <- dat
#calculate coordinates with new center of mass for PCA
dat_U$xn <- (dat_U$x-x_av)/max(dat$R)
dat_U$yn <- (dat_U$y-y_av)/max(dat$R)
dat_U$zn <- (dat_U$z-z_av)/max(dat$R)
#same for anchored
dat_A <- dat
dat_A$xn <- dat_A$x/max(dat$R)
dat_A$yn <- dat_A$y/max(dat$R)
dat_A$zn <- dat_A$z/max(dat$R)
#calculate S (senus Heslop, Tm in PmagDiR) elements
#elements of the distribution matrix
S_temp <- as.matrix(dat_U[,5:7])
S <- t(S_temp) %*% S_temp
S <- S/nrow(dat_U)
S_e <- eigen(S)
S_vec <- S_e$vectors
S_val <- S_e$value
#calculate Sa (senus Heslop, Tm in PmagDiR) elements
#elements of the distribution matrix
Sa_temp <- as.matrix(dat_A[,5:7])
Sa <- t(Sa_temp) %*% Sa_temp
Sa <- Sa/nrow(dat_A)
Sa_e <- eigen(Sa)
Sa_vec <- Sa_e$vectors
Sa_val <- Sa_e$value
#create identity matrix 3x3
I <- diag(3)
#starts the process for PPCA, First calculate everything to BIC for un-anchored data (dat_U,S)
sigma_U <- (S_val[2]+S_val[3])/2
Wu <- matrix(S_vec[,1]*sqrt(S_val[1]-sigma_U))
WTW <- Wu %*% t(Wu)
Cu <- (WTW)+(sigma_U*I)
dCu <- det(Cu)
iCu <- MASS::ginv(Cu)
LogLu <- -(nrow(dat_U)/2)*((3*log(2*pi))+(log(dCu))+(sum(diag(iCu %*% S))))
BIC_Hu <- (-2*LogLu)+(8*log(nrow(dat_U)))
#calculate Free Vector
Dec_U<- (r2d(atan2(Wu[2,1],Wu[1,1])))%%360
Inc_U <- r2d(asin(Wu[3,1]/(sqrt((Wu[1,1]^2)+(Wu[2,1]^2)+(Wu[3,1]^2)))))
MADu <- r2d(atan(sqrt((2*sigma_U/S_val[1]))))
#flipping Dec_U module, if directions goes opposite to vector tip
tip <- c(dat[1,1]-dat[nrow(dat),1],dat[1,2]-dat[nrow(dat),2],dat[1,3]-dat[nrow(dat),3])
tipdec <- (r2d(atan2(tip[2],tip[1])))%%360
tipinc <- r2d(asin(tip[3]/(sqrt((tip[1]^2)+(tip[2]^2)+(tip[3]^2)))))
deltadec_tip_V1_U<- abs(tipdec-Dec_U)
dist_tip_V1_U <- r2d(acos((sin(d2r(tipinc))*sin(d2r(Inc_U)))+
(cos(d2r(tipinc))*cos(d2r(Inc_U))*cos(d2r(deltadec_tip_V1_U)))))
if(dist_tip_V1_U>90){
Dec_U <- (Dec_U+180)%%360
Inc_U <- -Inc_U
}
#same process for anchored data
sigma_A <- (Sa_val[2]+Sa_val[3])/2
Wa <- matrix(Sa_vec[,1]*sqrt(Sa_val[1]-sigma_A))
WaTWa <- Wa %*% t(Wa)
Ca <- (WaTWa)+(sigma_A*I)
dCa <- det(Ca)
iCa <- MASS::ginv(Ca)
LogLa <- -(nrow(dat_A)/2)*((3*log(2*pi))+(log(dCa))+(sum(diag(iCa %*% Sa))))
BIC_Ha <- (-2*LogLa)+(5*log(nrow(dat_A)))
#calculate Anchored Vector
Dec_A<- (r2d(atan2(Wa[2,1],Wa[1,1])))%%360
Inc_A <- r2d(asin(Wa[3,1]/(sqrt((Wa[1,1]^2)+(Wa[2,1]^2)+(Wa[3,1]^2)))))
MADa <- r2d(atan(sqrt((2*sigma_A/Sa_val[1]))))
#flipping Dec_U module, if directions goes opposite to vector tip
deltadec_tip_V1_A<- abs(tipdec-Dec_A)
dist_tip_V1_A <- r2d(acos((sin(d2r(tipinc))*sin(d2r(Inc_A)))+
(cos(d2r(tipinc))*cos(d2r(Inc_A))*cos(d2r(deltadec_tip_V1_A)))))
if(dist_tip_V1_A>90){
Dec_A <- (Dec_A+180)%%360
Inc_A <- -Inc_A
}
#Calculate BF and probability
BF <- exp((BIC_Ha-BIC_Hu)/2)
pHa <- round((1/(BF+1)),digits = 3)
C_init_Sig <- sigma_U
C_init_Lam <- Wu[1,1]^2+Wu[2,1]^2+Wu[3,1]^2+(sigma_U)
N <- nrow(dat)
# Initial parameters for LogLc (constrained) estimate
start_vals <- c(sigma = C_init_Sig,
lambda = C_init_Lam)
#function for calculating LogLc
LogLc <- function(SL) {
sigma_sq <- SL[1]
lambda <- SL[2]
diff_val <- sqrt(lambda - sigma_sq)
norm_factor <- sqrt(x_av^2 + y_av^2 + z_av^2)
# Calcola Wc
Wc <- matrix(c(
(x_av / norm_factor) * diff_val,
(y_av / norm_factor) * diff_val,
(z_av / norm_factor) * diff_val),
nrow = 1, ncol = 3)
Noise <- sigma_sq * diag(3)
Cc <- (t(Wc) %*% Wc) + Noise
iCc <- solve(Cc)
# Determinante
dCc <- det(Cc)
# Controllo matrice inversa
if (any(is.nan(iCc)) || any(is.infinite(iCc))) {return(1e6)}
# Calcolo log-verosimiglianza
result <- -(N / 2) * ((3 * log(2 * pi)) + log(dCc) + sum(diag(iCc %*% S)))
return(result)
}
# Funzione di ottimizzazione con vincoli
optim_wrapper <- function(SL) {
sigma_sq <- SL[1]
lambda <- SL[2]
# Vincolo: lambda deve essere maggiore di sqrt(sigma_sq)
if (lambda <= sqrt(sigma_sq)) {
return(1e6)  # Penalità per violazione del vincolo
}
return(-LogLc(SL))  # Negativa perché ottimizziamo per minimizzazione
}
# Valori iniziali (che conosci già)
start_vals <- c(sigma_sq = C_init_Sig,
lambda = C_init_Lam)
# Ottimizzazione con vincoli
opt_result <- optim(
par = start_vals,
fn = optim_wrapper,
method = "L-BFGS-B",
lower = c(1e-6, sqrt(start_vals[1]) + 1e-6),  # Evitiamo valori negativi e rispettiamo il vincolo
upper = c(Inf, Inf)  # Nessun limite superiore
)
#extrapolate necessary values
Sigma_C <- opt_result$par[1]
Lambda_C <- opt_result$par[2]
LogLc <- -opt_result$value
BIC_Hc <- (-2*LogLc)+(5*log(nrow(dat_A)))
HuVsHc <- exp((BIC_Hc-BIC_Hu)/2)
#calculate probability
pHc <- round(1/(1+HuVsHc),digits = 3)
#otimized constrained vector matrix
WcO <- matrix(c(
(x_av/sqrt(x_av^2 + y_av^2 + z_av^2)) * sqrt(Lambda_C-Sigma_C),
(y_av/sqrt(x_av^2 + y_av^2 + z_av^2)) * sqrt(Lambda_C-Sigma_C),
(z_av/sqrt(x_av^2 + y_av^2 + z_av^2)) * sqrt(Lambda_C-Sigma_C)),
nrow = 3, ncol = 1)
#calculate constrained Vector
Dec_C <- (r2d(atan2(WcO[2,1],WcO[1,1])))%%360
Inc_C <- r2d(asin(WcO[3,1]/(sqrt((WcO[1,1]^2)+(WcO[2,1]^2)+(WcO[3,1]^2)))))
MADc <- r2d(atan(sqrt((2*Sigma_C)/Lambda_C)))
#flipping Dec_U module, if directions goes opposite to vector tip
deltadec_tip_V1_C <- abs(tipdec-Dec_C)
dist_tip_V1_C <- r2d(acos((sin(d2r(tipinc))*sin(d2r(Inc_C)))+
(cos(d2r(tipinc))*cos(d2r(Inc_C))*cos(d2r(deltadec_tip_V1_C)))))
if(dist_tip_V1_C>90){
Dec_C <- (Dec_C+180)%%360
Inc_C <- -Inc_C
}
#producing text on anchoring
if(pHa<0.5){text1 <- "Free from origin interpolation"}
if(pHa>0.5){text1 <- "Anchored interpolation"}
if(pHa<0.01 || pHa >= 0.99) {text2 <- "very strongly"}
if((pHa>=0.01 && pHa<0.05) || (pHa>=0.95 && pHa<0.99)) {text2 <- "strongly"}
if((pHa>=0.05 && pHa<0.25) || (pHa>=0.75 && pHa<0.95)) {text2 <- "positively"}
if((pHa>=0.25 && pHa<0.5) || (pHa>0.5 && pHa<0.75)) {text2 <- "weakly"}
if(pHa==0.5){verdict <- "No preference about anchoring to the origin"}
else{verdict_a <- paste("p(Ha|D)=",pHa,text1,"is",text2,"supported",sep = " ")}
#producing text on constraining
if(pHc<0.5){text3 <- "Unconstrained interpolation"}
if(pHc>0.5){text3 <- "Constrained interpolation"}
if(pHc<0.01 || pHc >= 0.99) {text4 <- "very strongly"}
if((pHc>=0.01 && pHc<0.05) || (pHc>=0.95 && pHc<0.99)) {text4 <- "strongly"}
if((pHc>=0.05 && pHc<0.25) || (pHc>=0.75 && pHc<0.95)) {text4 <- "positively"}
if((pHc>=0.25 && pHc<0.5) || (pHc>0.5 && pHc<0.75)) {text4 <- "weakly"}
if(pHc==0.5){verdict_c <- "No preference about constraining"}
else{verdict_c <- paste("p(Hc|D)=",pHc,text3,"is",text4,"supported",sep = " ")}
#compile results table
All_directions <- data.frame(matrix(nrow = 3,ncol=6))
colnames(All_directions)=c("Dec","Inc","MAD","N","Log likelihood","BIC")
rownames(All_directions)=c("Free","Anchored","Constrained")
#compile result table
All_directions[1,1:6]=round(c(Dec_U,Inc_U,MADu,N,LogLu,BIC_Hu),digits = 2)
All_directions[2,1:6]=round(c(Dec_A,Inc_A,MADa,N,LogLa,BIC_Ha),digits = 2)
All_directions[3,1:6]=round(c(Dec_C,Inc_C,MADc,N,LogLc,BIC_Hc),digits = 2)
results <- list()
results$All_directions <- All_directions
results$verdict_a <- verdict_a
results$verdict_c <- verdict_c
results$pHa <- pHa
results$pHc <- pHc
return(results)
}
PPCA_HR16(butta)
library(devtools)
install_github("edoardo-paleomag/PmagDiR)
install_github("edoardo-paleomag/PmagDiR")
library(shiny); runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_51.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_51.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_51.R')
library(PmagDiR)
PmagDiR::PPCA_HR16(butta)
library(shiny); runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_51.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_51.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_51.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_51.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_51.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_51.R')
library(PmagDiR)
?IODP_PLOT
?IODP_LOG
library(PmagDiR)
IODP_plot()
IODP_plot()
IODP_plot()
IODP_plot()
library(devtools)
install_github("edoardo-paleomag/PmagDiR")
PmagDiR::IODP_plot()
shiny::runGitHub("Magnetic-A","edoardo-paleomag")
library(devtools)
install_github("edoardo-paleomag/PmagDiR")
#importa dati
dat <- as.data.frame(read.csv(file.choose()))
View(MVGP_temp)
library(shiny); runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_53.R')
View(MVGP_temp)
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_53.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_53_bbbb.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_53_bbbb.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_53_bbbb.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_53_bbbb.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_53_bbbb.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_53_bbbb.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_53_bbbb.R')
shiny::runGitHub("Magnetic-A","edoardo-paleomag")
shiny::runGitHub("Magnetic-A","edoardo-paleomag")
runApp('Desktop/Softwares_EDO/R_plots/Shiny/MagneticA2/Web_PmagDiR_53_2.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/MagneticA2/Web_PmagDiR_53_2.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/MagneticA2/Web_PmagDiR_53_2.R')
shiny::runGitHub("Magnetic-A","edoardo-paleomag")
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_3.R')
library(shiny)
library(plotly)
ui <- fluidPage(
plotlyOutput("plot"),
verbatimTextOutput("click")
)
server <- function(input, output, session) {
nms <- row.names(mtcars)
output$plot <- renderPlotly({
p <- ggplot(mtcars, aes(x = mpg, y = wt, col = as.factor(cyl), key = nms)) +
geom_point()
ggplotly(p)
})
output$click <- renderPrint({
d <- event_data("plotly_click")
if (is.null(d)) "Click events appear here (double-click to clear)"
else cat("Selected point associated with Car: ", d$key)
})
}
shinyApp(ui, server)
?nearPoints
ui <- fluidPage(
plotOutput("plot", click = "plot_click"),
tableOutput("data")
)
server <- function(input, output, session) {
output$plot <- renderPlot({
plot(mtcars$wt, mtcars$mpg)
}, res = 96)
output$data <- renderTable({
nearPoints(mtcars, input$plot_click, xvar = "wt", yvar = "mpg")
})
}
shinyApp(ui = ui,server = server)
shiny::runGitHub("Magnetic-A","edoardo-paleomag")
ui <- fluidPage(mainPanel(
plotOutput("plot1", click="plot_click"),
plotOutput("plot2")
))
server <- function(input, output) {
output$plot1 <- renderPlot({
plot(x,y)
})
output$plot2 <- renderPlot({
plot(x,y)
df <- nearPoints(data.frame(x=x,y=y),input$plot_click,maxpoints=1,"x","y")
points(df[1],df[2],cex=3,lwd=3,col="blue")
})
}
x <- rnorm(100)
y <- rnorm(100)
shinyApp(ui = ui, server = server)
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
View(buttaPoint)
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
View(buttaDirs)
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
?abs()
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
runApp('Desktop/Softwares_EDO/R_plots/Shiny/Web_PmagDiR_54.R')
shiny::runGitHub("Magnetic-A","edoardo-paleomag")
shiny::runApp('Documents/GitHub/Magnetic-A_github')
butta_selected_steps
shiny::runApp('Documents/GitHub/Magnetic-A_github')
shiny::runApp('Documents/GitHub/Magnetic-A_github')
shiny::runApp('Documents/GitHub/Magnetic-A_github')
shiny::runGitHub("Magnetic-A","edoardo-paleomag")
